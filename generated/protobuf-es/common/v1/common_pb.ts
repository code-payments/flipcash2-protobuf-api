// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file common/v1/common.proto (package flipcash.common.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from enum flipcash.common.v1.Platform
 */
export enum Platform {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: APPLE = 1;
   */
  APPLE = 1,

  /**
   * @generated from enum value: GOOGLE = 2;
   */
  GOOGLE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Platform)
proto3.util.setEnumType(Platform, "flipcash.common.v1.Platform", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "APPLE" },
  { no: 2, name: "GOOGLE" },
]);

/**
 * @generated from message flipcash.common.v1.PublicKey
 */
export class PublicKey extends Message<PublicKey> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<PublicKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.common.v1.PublicKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublicKey {
    return new PublicKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublicKey {
    return new PublicKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublicKey {
    return new PublicKey().fromJsonString(jsonString, options);
  }

  static equals(a: PublicKey | PlainMessage<PublicKey> | undefined, b: PublicKey | PlainMessage<PublicKey> | undefined): boolean {
    return proto3.util.equals(PublicKey, a, b);
  }
}

/**
 * @generated from message flipcash.common.v1.Signature
 */
export class Signature extends Message<Signature> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Signature>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.common.v1.Signature";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Signature {
    return new Signature().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Signature {
    return new Signature().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Signature {
    return new Signature().fromJsonString(jsonString, options);
  }

  static equals(a: Signature | PlainMessage<Signature> | undefined, b: Signature | PlainMessage<Signature> | undefined): boolean {
    return proto3.util.equals(Signature, a, b);
  }
}

/**
 * Auth provides an authentication information for RPCs/messages.
 *
 * Currently, only a single form is supported, but it may be useful in
 * the future to rely on session tokens instead.
 *
 * @generated from message flipcash.common.v1.Auth
 */
export class Auth extends Message<Auth> {
  /**
   * @generated from oneof flipcash.common.v1.Auth.kind
   */
  kind: {
    /**
     * KeyPair uses pub key cryptography to verify.
     *
     * @generated from field: flipcash.common.v1.Auth.KeyPair key_pair = 1;
     */
    value: Auth_KeyPair;
    case: "keyPair";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Auth>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.common.v1.Auth";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key_pair", kind: "message", T: Auth_KeyPair, oneof: "kind" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Auth {
    return new Auth().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Auth {
    return new Auth().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Auth {
    return new Auth().fromJsonString(jsonString, options);
  }

  static equals(a: Auth | PlainMessage<Auth> | undefined, b: Auth | PlainMessage<Auth> | undefined): boolean {
    return proto3.util.equals(Auth, a, b);
  }
}

/**
 * KeyPair uses a keypair to verify a message.
 *
 * The signature should be of the encapsulating proto message,
 * _without_ the Auth section being set.
 *
 * @generated from message flipcash.common.v1.Auth.KeyPair
 */
export class Auth_KeyPair extends Message<Auth_KeyPair> {
  /**
   * @generated from field: flipcash.common.v1.PublicKey pub_key = 1;
   */
  pubKey?: PublicKey;

  /**
   * @generated from field: flipcash.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<Auth_KeyPair>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.common.v1.Auth.KeyPair";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pub_key", kind: "message", T: PublicKey },
    { no: 2, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Auth_KeyPair {
    return new Auth_KeyPair().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Auth_KeyPair {
    return new Auth_KeyPair().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Auth_KeyPair {
    return new Auth_KeyPair().fromJsonString(jsonString, options);
  }

  static equals(a: Auth_KeyPair | PlainMessage<Auth_KeyPair> | undefined, b: Auth_KeyPair | PlainMessage<Auth_KeyPair> | undefined): boolean {
    return proto3.util.equals(Auth_KeyPair, a, b);
  }
}

/**
 * @generated from message flipcash.common.v1.UserId
 */
export class UserId extends Message<UserId> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<UserId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.common.v1.UserId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserId {
    return new UserId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserId {
    return new UserId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserId {
    return new UserId().fromJsonString(jsonString, options);
  }

  static equals(a: UserId | PlainMessage<UserId> | undefined, b: UserId | PlainMessage<UserId> | undefined): boolean {
    return proto3.util.equals(UserId, a, b);
  }
}

/**
 * AppInstallId is a unque ID tied to a client app installation. It does not
 * identify a device. Value should remain private and not be shared across
 * installs.
 *
 * @generated from message flipcash.common.v1.AppInstallId
 */
export class AppInstallId extends Message<AppInstallId> {
  /**
   * @generated from field: string value = 1;
   */
  value = "";

  constructor(data?: PartialMessage<AppInstallId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.common.v1.AppInstallId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppInstallId {
    return new AppInstallId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppInstallId {
    return new AppInstallId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppInstallId {
    return new AppInstallId().fromJsonString(jsonString, options);
  }

  static equals(a: AppInstallId | PlainMessage<AppInstallId> | undefined, b: AppInstallId | PlainMessage<AppInstallId> | undefined): boolean {
    return proto3.util.equals(AppInstallId, a, b);
  }
}

/**
 * CryptoPaymentAmount defines an amount of crypto with currency exchange data
 *
 * @generated from message flipcash.common.v1.CryptoPaymentAmount
 */
export class CryptoPaymentAmount extends Message<CryptoPaymentAmount> {
  /**
   * ISO 4217 alpha-3 currency code the payment was made in
   *
   * @generated from field: string currency = 1;
   */
  currency = "";

  /**
   * The amount in the native currency that was paid
   *
   * @generated from field: double native_amount = 2;
   */
  nativeAmount = 0;

  /**
   * The amount in quarks of crypto that was paid
   *
   * @generated from field: uint64 quarks = 3;
   */
  quarks = protoInt64.zero;

  /**
   * The crypto mint that was paid
   *
   * @generated from field: flipcash.common.v1.PublicKey mint = 4;
   */
  mint?: PublicKey;

  constructor(data?: PartialMessage<CryptoPaymentAmount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.common.v1.CryptoPaymentAmount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "native_amount", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "quarks", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "mint", kind: "message", T: PublicKey },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CryptoPaymentAmount {
    return new CryptoPaymentAmount().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CryptoPaymentAmount {
    return new CryptoPaymentAmount().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CryptoPaymentAmount {
    return new CryptoPaymentAmount().fromJsonString(jsonString, options);
  }

  static equals(a: CryptoPaymentAmount | PlainMessage<CryptoPaymentAmount> | undefined, b: CryptoPaymentAmount | PlainMessage<CryptoPaymentAmount> | undefined): boolean {
    return proto3.util.equals(CryptoPaymentAmount, a, b);
  }
}

/**
 * FiatPaymentAmount defines an amount of fiat
 *
 * @generated from message flipcash.common.v1.FiatPaymentAmount
 */
export class FiatPaymentAmount extends Message<FiatPaymentAmount> {
  /**
   * ISO 4217 alpha-3 currency code the payment was made in
   *
   * @generated from field: string currency = 1;
   */
  currency = "";

  /**
   * The amount in the native currency that was paid
   *
   * @generated from field: double native_amount = 2;
   */
  nativeAmount = 0;

  constructor(data?: PartialMessage<FiatPaymentAmount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.common.v1.FiatPaymentAmount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "native_amount", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FiatPaymentAmount {
    return new FiatPaymentAmount().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FiatPaymentAmount {
    return new FiatPaymentAmount().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FiatPaymentAmount {
    return new FiatPaymentAmount().fromJsonString(jsonString, options);
  }

  static equals(a: FiatPaymentAmount | PlainMessage<FiatPaymentAmount> | undefined, b: FiatPaymentAmount | PlainMessage<FiatPaymentAmount> | undefined): boolean {
    return proto3.util.equals(FiatPaymentAmount, a, b);
  }
}

/**
 * @generated from message flipcash.common.v1.PagingToken
 */
export class PagingToken extends Message<PagingToken> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<PagingToken>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.common.v1.PagingToken";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PagingToken {
    return new PagingToken().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PagingToken {
    return new PagingToken().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PagingToken {
    return new PagingToken().fromJsonString(jsonString, options);
  }

  static equals(a: PagingToken | PlainMessage<PagingToken> | undefined, b: PagingToken | PlainMessage<PagingToken> | undefined): boolean {
    return proto3.util.equals(PagingToken, a, b);
  }
}

/**
 * @generated from message flipcash.common.v1.QueryOptions
 */
export class QueryOptions extends Message<QueryOptions> {
  /**
   * PageSize limits the maximum page size of a response.
   *
   * Server may choose to return less items. If <= 0,
   * server may select an arbitrary default page size.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0;

  /**
   * PagingToken is a token that can be extracted from the
   * identifier of a collection.
   *
   * @generated from field: flipcash.common.v1.PagingToken paging_token = 2;
   */
  pagingToken?: PagingToken;

  /**
   * Order is the order of elements, if applicable.
   *
   * @generated from field: flipcash.common.v1.QueryOptions.Order order = 3;
   */
  order = QueryOptions_Order.ASC;

  constructor(data?: PartialMessage<QueryOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.common.v1.QueryOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "paging_token", kind: "message", T: PagingToken },
    { no: 3, name: "order", kind: "enum", T: proto3.getEnumType(QueryOptions_Order) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryOptions {
    return new QueryOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryOptions {
    return new QueryOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryOptions {
    return new QueryOptions().fromJsonString(jsonString, options);
  }

  static equals(a: QueryOptions | PlainMessage<QueryOptions> | undefined, b: QueryOptions | PlainMessage<QueryOptions> | undefined): boolean {
    return proto3.util.equals(QueryOptions, a, b);
  }
}

/**
 * @generated from enum flipcash.common.v1.QueryOptions.Order
 */
export enum QueryOptions_Order {
  /**
   * @generated from enum value: ASC = 0;
   */
  ASC = 0,

  /**
   * @generated from enum value: DESC = 1;
   */
  DESC = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(QueryOptions_Order)
proto3.util.setEnumType(QueryOptions_Order, "flipcash.common.v1.QueryOptions.Order", [
  { no: 0, name: "ASC" },
  { no: 1, name: "DESC" },
]);

/**
 * Request is a generic wrapper for gRPC requests
 *
 * @generated from message flipcash.common.v1.Request
 */
export class Request extends Message<Request> {
  /**
   * @generated from field: string version = 1;
   */
  version = "";

  /**
   * @generated from field: string service = 2;
   */
  service = "";

  /**
   * @generated from field: string method = 3;
   */
  method = "";

  /**
   * @generated from field: bytes body = 4;
   */
  body = new Uint8Array(0);

  constructor(data?: PartialMessage<Request>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.common.v1.Request";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "service", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "body", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Request {
    return new Request().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Request {
    return new Request().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Request {
    return new Request().fromJsonString(jsonString, options);
  }

  static equals(a: Request | PlainMessage<Request> | undefined, b: Request | PlainMessage<Request> | undefined): boolean {
    return proto3.util.equals(Request, a, b);
  }
}

/**
 * Response is a generic wrapper for gRPC responses
 *
 * @generated from message flipcash.common.v1.Response
 */
export class Response extends Message<Response> {
  /**
   * @generated from field: flipcash.common.v1.Response.Result result = 1;
   */
  result = Response_Result.OK;

  /**
   * @generated from field: bytes body = 2;
   */
  body = new Uint8Array(0);

  /**
   * @generated from field: string message = 3;
   */
  message = "";

  constructor(data?: PartialMessage<Response>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.common.v1.Response";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(Response_Result) },
    { no: 2, name: "body", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Response {
    return new Response().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Response {
    return new Response().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Response {
    return new Response().fromJsonString(jsonString, options);
  }

  static equals(a: Response | PlainMessage<Response> | undefined, b: Response | PlainMessage<Response> | undefined): boolean {
    return proto3.util.equals(Response, a, b);
  }
}

/**
 * @generated from enum flipcash.common.v1.Response.Result
 */
export enum Response_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: ERROR = 1;
   */
  ERROR = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(Response_Result)
proto3.util.setEnumType(Response_Result, "flipcash.common.v1.Response.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "ERROR" },
]);

/**
 * @generated from message flipcash.common.v1.CountryCode
 */
export class CountryCode extends Message<CountryCode> {
  /**
   * ISO 3166-1 Alpha-2
   *
   * @generated from field: string value = 1;
   */
  value = "";

  constructor(data?: PartialMessage<CountryCode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.common.v1.CountryCode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountryCode {
    return new CountryCode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountryCode {
    return new CountryCode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountryCode {
    return new CountryCode().fromJsonString(jsonString, options);
  }

  static equals(a: CountryCode | PlainMessage<CountryCode> | undefined, b: CountryCode | PlainMessage<CountryCode> | undefined): boolean {
    return proto3.util.equals(CountryCode, a, b);
  }
}

